package org.zhare.leetcode.algorithms;

/**
 * @author xufeng.deng dennisdxf@gmail.com
 * @since 2019/10/11
 */
public class Complexity {
    /*
     * 一、时间复杂度
     * 众所周知，所有代码的执行时间T(n)和代码执行的次数n是呈正比的关系。这种规律可以总结成T(n) = O(f(n))
     * T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。
     *
     * 公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。即为大O时间复杂度表示法。
     * 表示的是【代码执行时间】随【数据规模增长】的【变化趋势】。
     * 公式中的【低阶】、【常量】、【系数】三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。
     *
     * 也叫渐进式时间复杂度。
     *
     * 分析方法：
     * 1.只关注循环次数最多的一段代码
     * 2.加法原则，即总复杂度等于量级最大的那段代码的复杂度
     * 3.乘法原则，即嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
     *
     * 常见复杂度：常量阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、k方阶O(n^k)、阶乘阶O(n!)、指数阶O(2^n)
     *
     * 几种时间复杂度：
     * 平均情况时间复杂度，概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。
     * 最好情况时间复杂度，在最理想的情况下，执行这段代码的时间复杂度
     * 最坏情况时间复杂度，在最糟糕的情况下，执行这段代码的时间复杂度
     * 均摊时间复杂度，通过摊还分析法所得，均摊时间复杂度就是一种特殊的平均时间复杂度
     *
     * 二、空间复杂度
     * 类比时间复杂度，空间复杂度全程为【渐进式空间复杂度】。表示的是，算法的存储空间与数据规模增之间的增长关系。
     *
     * */
}
